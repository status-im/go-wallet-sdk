package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"go/format"
	"log"
	"os"
	"regexp"
	"strings"
	"text/template"
)

// Deployment represents a single deployment entry from the JSON file
type Deployment struct {
	Name    string `json:"name"`
	ChainID int64  `json:"chainId"`
	URL     string `json:"url"`
}

// AddressInfo represents the parsed address information
type AddressInfo struct {
	Name    string
	ChainID int64
	Address string
}

// GoTemplate is the template for generating the deployments.go file
const GoTemplate = `// Code generated by deployments/main.go. DO NOT EDIT.

package multicall3

import (
	"github.com/ethereum/go-ethereum/common"
)

// Multicall3Addresses maps chain ID to the deployed Multicall3 contract address
var Multicall3Addresses = map[int64]common.Address{
{{range .}}	{{.ChainID}}: common.HexToAddress("{{.Address}}"), // {{.Name}}
{{end}}}

// GetMulticall3Address returns the Multicall3 contract address for the given chain ID
func GetMulticall3Address(chainID int64) (common.Address, bool) {
	addr, exists := Multicall3Addresses[chainID]
	return addr, exists
}

// IsChainSupported returns true if the given chain ID has a deployed Multicall3 contract
func IsChainSupported(chainID int64) bool {
	_, exists := Multicall3Addresses[chainID]
	return exists
}

// GetSupportedChainIDs returns a slice of all supported chain IDs
func GetSupportedChainIDs() []int64 {
	chainIDs := make([]int64, 0, len(Multicall3Addresses))
	for chainID := range Multicall3Addresses {
		chainIDs = append(chainIDs, chainID)
	}
	return chainIDs
}
`

func parseDeployments(path string) ([]Deployment, error) {
	// Read the file
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}
	// Parse the JSON data
	var deployments []Deployment
	if err := json.Unmarshal(data, &deployments); err != nil {
		return nil, err
	}
	return deployments, nil
}

func main() {
	// Parse official deployments list
	officialDeployments, err := parseDeployments("deployments.json")
	if err != nil {
		log.Fatalf("Failed to parse deployments.json: %v", err)
	}

	// Parse extra deployments, not part of the official list
	extraDeployments, err := parseDeployments("extra_deployments.json")
	if err != nil {
		log.Fatalf("Failed to parse extra_deployments.json: %v", err)
	}

	// Combine lists
	deployments := append(officialDeployments, extraDeployments...)

	// Extract addresses from URLs using regex
	addressRegex := regexp.MustCompile(`0x[a-fA-F0-9]{40}`)
	addressMap := make(map[int64]string) // Use map to handle duplicates
	var addressInfos []AddressInfo

	for _, deployment := range deployments {
		// Find the first match of the address pattern in the URL
		matches := addressRegex.FindString(deployment.URL)
		if matches != "" {
			// Only add if we haven't seen this chain ID before (keep first occurrence)
			if _, exists := addressMap[deployment.ChainID]; !exists {
				addressMap[deployment.ChainID] = strings.ToLower(matches)
				addressInfos = append(addressInfos, AddressInfo{
					Name:    deployment.Name,
					ChainID: deployment.ChainID,
					Address: strings.ToLower(matches), // Normalize to lowercase
				})
			} else {
				log.Printf("Warning: Duplicate chain ID %d (%s), keeping first occurrence",
					deployment.ChainID, deployment.Name)
			}
		} else {
			log.Printf("Warning: No address found in URL for chain %d (%s): %s",
				deployment.ChainID, deployment.Name, deployment.URL)
		}
	}

	// Parse and execute the template
	tmpl, err := template.New("deployments").Parse(GoTemplate)
	if err != nil {
		log.Fatalf("Failed to parse template: %v", err)
	}

	var buffer bytes.Buffer
	if err := tmpl.Execute(&buffer, addressInfos); err != nil {
		log.Fatalf("Failed to execute template: %v", err)
	}

	p, err := format.Source(buffer.Bytes())
	if err != nil {
		log.Fatalf("Failed to format source: %v", err)
	}

	// Create the output file
	outputFile, err := os.Create("../deployments.go")
	if err != nil {
		log.Fatalf("Failed to create ../deployments.go: %v", err)
	}
	defer outputFile.Close()

	_, err = outputFile.Write(p)
	if err != nil {
		log.Fatalf("Failed to write to ../deployments.go: %v", err)
	}

	fmt.Printf("Successfully generated deployments.go with %d unique chain addresses\n", len(addressInfos))
}
