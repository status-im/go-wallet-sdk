#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <pthread.h>
#include <unistd.h>

// Header generated by Go build -buildmode=c-shared
#include "libgowalletsdk.h"

// Forward declarations for cancellation functions (will be in header after rebuild)
extern char* GoWSK_balance_multistandardfetcher_FetchBalances(uintptr_t ethClientHandle, unsigned long chainIDC, unsigned long batchSizeC, char* fetchConfigJSONCStr, uintptr_t* cancelHandleOut, char** errOut);
extern void GoWSK_balance_multistandardfetcher_CancelFetchBalances(uintptr_t cancelHandle);
extern void GoWSK_balance_multistandardfetcher_FreeCancelHandle(uintptr_t cancelHandle);

// Structure to pass data to the fetch thread
typedef struct {
    uintptr_t ethClientHandle;
    unsigned long chainID;
    unsigned long batchSize;
    const char* fetchConfigJSON;
    uintptr_t cancelHandle;
    char* resultsJSON;
    char* err;
    int completed;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
} fetch_thread_data_t;

// Thread function to run FetchBalances
static void* fetch_thread_func(void* arg) {
    fetch_thread_data_t* data = (fetch_thread_data_t*)arg;
    
    // Run FetchBalances in this thread
    uintptr_t localCancelHandle = 0;
    data->resultsJSON = GoWSK_balance_multistandardfetcher_FetchBalances(
        data->ethClientHandle,
        data->chainID,
        data->batchSize,
        (char*)data->fetchConfigJSON,
        &localCancelHandle,
        &data->err
    );
    
    // Signal completion and copy cancelHandle under mutex
    pthread_mutex_lock(&data->mutex);
    data->cancelHandle = localCancelHandle;
    data->completed = 1;
    pthread_cond_signal(&data->cond);
    pthread_mutex_unlock(&data->mutex);
    
    return NULL;
}

// Example: Basic operations (ChainID, GetBalance, RPCCall)
static int example_basic_operations(uintptr_t clientHandle, const char* address) {
    char* err = NULL;
    
    // Get ChainID
    char* chain = GoWSK_ethclient_ChainID(clientHandle, &err);
    if (chain == NULL) {
        fprintf(stderr, "ChainID error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }
    printf("ChainID: %s\n", chain);
    GoWSK_FreeCString(chain);
    
    // Get Balance
    char* balance = GoWSK_ethclient_GetBalance(clientHandle, (char*)address, &err);
    if (balance == NULL) {
        fprintf(stderr, "GetBalance error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }
    printf("Balance(wei): %s\n", balance);
    GoWSK_FreeCString(balance);
    
    // RPC Call
    char* method = "eth_getBalance";
    char* params = "[\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\",\"latest\"]";
    char* rpcCallResponse = GoWSK_ethclient_RPCCall(clientHandle, method, params, &err);
    if (rpcCallResponse == NULL) {
        fprintf(stderr, "RPCCall error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }
    printf("RPCCall\nMethod: %s\nParams: %s\nResponse: %s\n", method, params, rpcCallResponse);
    GoWSK_FreeCString(rpcCallResponse);
    
    return 0;
}

// Example: Cancellation with threading
static int example_cancellation_with_threading(uintptr_t clientHandle, unsigned long chainID, const char* fetchConfigJSON) {
    printf("\n--- Example: Cancellation with threading ---\n");
    
    // Initialize thread data
    fetch_thread_data_t thread_data = {
        .ethClientHandle = clientHandle,
        .chainID = chainID,
        .batchSize = 1,  // Small batch size to make it slower and easier to cancel
        .fetchConfigJSON = fetchConfigJSON,
        .cancelHandle = 0,
        .resultsJSON = NULL,
        .err = NULL,
        .completed = 0
    };
    pthread_mutex_init(&thread_data.mutex, NULL);
    pthread_cond_init(&thread_data.cond, NULL);
    
    // Start the fetch in a separate thread
    pthread_t fetch_thread;
    printf("Starting fetch operation in background thread...\n");
    if (pthread_create(&fetch_thread, NULL, fetch_thread_func, &thread_data) != 0) {
        fprintf(stderr, "Failed to create thread\n");
        pthread_mutex_destroy(&thread_data.mutex);
        pthread_cond_destroy(&thread_data.cond);
        return 1;
    }
    
    // Wait a short time, then cancel the operation
    printf("Waiting 1000ms before cancelling...\n");
    usleep(1000000);  // 1000ms
    
    // Check if we have a cancel handle and cancel
    pthread_mutex_lock(&thread_data.mutex);
    if (thread_data.cancelHandle != 0) {
        printf("Cancelling fetch operation (cancel handle: %lu)...\n", (unsigned long)thread_data.cancelHandle);
        GoWSK_balance_multistandardfetcher_CancelFetchBalances(thread_data.cancelHandle);
    }
    pthread_mutex_unlock(&thread_data.mutex);
    
    // Wait for the thread to complete
    pthread_join(fetch_thread, NULL);
    
    // Process results
    pthread_mutex_lock(&thread_data.mutex);
    if (thread_data.resultsJSON != NULL) {
        printf("Fetch returned (may be partial due to cancellation):\n%s\n", thread_data.resultsJSON);
        GoWSK_FreeCString(thread_data.resultsJSON);
    } else if (thread_data.err != NULL) {
        printf("Fetch error: %s\n", thread_data.err);
        GoWSK_FreeCString(thread_data.err);
    }
    
    // Clean up cancel handle
    if (thread_data.cancelHandle != 0) {
        GoWSK_balance_multistandardfetcher_FreeCancelHandle(thread_data.cancelHandle);
    }
    pthread_mutex_unlock(&thread_data.mutex);
    
    // Clean up synchronization primitives
    pthread_mutex_destroy(&thread_data.mutex);
    pthread_cond_destroy(&thread_data.cond);
    
    return 0;
}

// Example: Full fetch without cancellation
static int example_full_fetch(uintptr_t clientHandle, unsigned long chainID, const char* fetchConfigJSON) {
    printf("\n--- Example: Full fetch operation ---\n");
    
    char* err = NULL;
    uintptr_t cancelHandle = 0;
    unsigned long batchSize = 100;
    
    char* resultsJSON = GoWSK_balance_multistandardfetcher_FetchBalances(
        clientHandle, 
        chainID, 
        batchSize, 
        (char*)fetchConfigJSON,
        &cancelHandle,  // Get cancel handle (but don't use it)
        &err
    );
    
    if (resultsJSON == NULL) {
        fprintf(stderr, "FetchBalances error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        if (cancelHandle != 0) {
            GoWSK_balance_multistandardfetcher_FreeCancelHandle(cancelHandle);
        }
        return 1;
    }
    
    printf("FetchBalances Results:\n%s\n", resultsJSON);
    GoWSK_FreeCString(resultsJSON);
    
    // Clean up the cancel handle
    if (cancelHandle != 0) {
        GoWSK_balance_multistandardfetcher_FreeCancelHandle(cancelHandle);
    }
    
    return 0;
}

int main(int argc, char** argv) {
    const char* url = "https://ethereum-rpc.publicnode.com";
    const char* addr = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"; // vitalik.eth

    char* err = NULL;
    unsigned long long h = GoWSK_ethclient_NewClient((char*)url, &err);
    if (h == 0) {
        fprintf(stderr, "Failed to create client: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }

    // Get chain ID for later examples
    char* chain = GoWSK_ethclient_ChainID(h, &err);
    if (chain == NULL) {
        fprintf(stderr, "ChainID error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }
    // Parse chain ID before freeing the string
    char* endptr;
    unsigned long chainID = strtoul(chain, &endptr, 0);
    if (*endptr != '\0' || endptr == chain) {
        fprintf(stderr, "Failed to parse chain ID\n");
        GoWSK_FreeCString(chain);
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }
    GoWSK_FreeCString(chain);

    // Run basic operations example
    if (example_basic_operations((uintptr_t)h, addr) != 0) {
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }

    // Example: Fetch balances using multistandardfetcher
    printf("\n=== Fetching balances with multistandardfetcher ===\n");
    
    // Create fetch config JSON: native balance + ERC20 tokens + ERC721 NFTs + ERC1155 collectibles
    // ERC20 tokens:
    //   USDC: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48
    //   SHIB: 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE
    // ERC721 NFTs:
    //   Bored Ape Yacht Club: 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
    //   Pudgy Penguins: 0xbd3531da5cf5857e7cfaa92426877b022e612cf8
    // ERC1155 collectibles (format: "contractAddress:tokenID"):
    //   OpenSea Shared Storefront: 0x495f947276749Ce646f68AC8c248420045cb7b5e:80725417304363601833901294931248829736335313578142415985923215537121414611044
    //   Parallel Alpha: 0x76BE3b62873462d2142405439777e971754E8E77:1
    const char* fetchConfigJSON = 
        "{"
        "\"native\":[\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\"],"
        "\"erc20\":{"
        "\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\":["
        "\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\","
        "\"0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE\""
        "]"
        "},"
        "\"erc721\":{"
        "\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\":["
        "\"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\","
        "\"0xbd3531da5cf5857e7cfaa92426877b022e612cf8\""
        "]"
        "},"
        "\"erc1155\":{"
        "\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\":["
        "\"0x495f947276749Ce646f68AC8c248420045cb7b5e:80725417304363601833901294931248829736335313578142415985923215537121414611044\","
        "\"0x76BE3b62873462d2142405439777e971754E8E77:1\""
        "]"
        "}"
        "}";
    
    // Run cancellation example
    if (example_cancellation_with_threading((uintptr_t)h, chainID, fetchConfigJSON) != 0) {
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }
    
    // Run full fetch example
    if (example_full_fetch((uintptr_t)h, chainID, fetchConfigJSON) != 0) {
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }

    GoWSK_ethclient_CloseClient(h);
    return 0;
}
