#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdint.h>
#include <pthread.h>
#include <unistd.h>
#include <time.h>
#include <dirent.h>
#include <sys/stat.h>

// Header generated by Go build -buildmode=c-shared
#include "libgowalletsdk.h"

// Structure to pass data to the fetch thread
typedef struct {
    uintptr_t ethClientHandle;
    unsigned long chainID;
    unsigned long batchSize;
    const char* fetchConfigJSON;
    uintptr_t cancelHandle;
    char* resultsJSON;
    char* err;
    int completed;
    pthread_mutex_t mutex;
    pthread_cond_t cond;
} fetch_thread_data_t;

// Thread function to run FetchBalances
static void* fetch_thread_func(void* arg) {
    fetch_thread_data_t* data = (fetch_thread_data_t*)arg;
    
    // Run FetchBalances in this thread
    uintptr_t localCancelHandle = 0;
    data->resultsJSON = GoWSK_balance_multistandardfetcher_FetchBalances(
        data->ethClientHandle,
        data->chainID,
        data->batchSize,
        (char*)data->fetchConfigJSON,
        &localCancelHandle,
        &data->err
    );
    
    // Signal completion and copy cancelHandle under mutex
    pthread_mutex_lock(&data->mutex);
    data->cancelHandle = localCancelHandle;
    data->completed = 1;
    pthread_cond_signal(&data->cond);
    pthread_mutex_unlock(&data->mutex);
    
    return NULL;
}

// Example: Basic operations (ChainID, GetBalance, RPCCall)
static int example_basic_operations(uintptr_t clientHandle, const char* address) {
    char* err = NULL;
    
    // Get ChainID
    char* chain = GoWSK_ethclient_ChainID(clientHandle, &err);
    if (chain == NULL) {
        fprintf(stderr, "ChainID error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }
    printf("ChainID: %s\n", chain);
    GoWSK_FreeCString(chain);
    
    // Get Balance
    char* balance = GoWSK_ethclient_GetBalance(clientHandle, (char*)address, &err);
    if (balance == NULL) {
        fprintf(stderr, "GetBalance error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }
    printf("Balance(wei): %s\n", balance);
    GoWSK_FreeCString(balance);
    
    // RPC Call
    char* method = "eth_getBalance";
    char* params = "[\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\",\"latest\"]";
    char* rpcCallResponse = GoWSK_ethclient_RPCCall(clientHandle, method, params, &err);
    if (rpcCallResponse == NULL) {
        fprintf(stderr, "RPCCall error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }
    printf("RPCCall\nMethod: %s\nParams: %s\nResponse: %s\n", method, params, rpcCallResponse);
    GoWSK_FreeCString(rpcCallResponse);
    
    return 0;
}

// Example: Cancellation with threading
static int example_cancellation_with_threading(uintptr_t clientHandle, unsigned long chainID, const char* fetchConfigJSON) {
    printf("\n--- Example: Cancellation with threading ---\n");
    
    // Initialize thread data
    fetch_thread_data_t thread_data = {
        .ethClientHandle = clientHandle,
        .chainID = chainID,
        .batchSize = 1,  // Small batch size to make it slower and easier to cancel
        .fetchConfigJSON = fetchConfigJSON,
        .cancelHandle = 0,
        .resultsJSON = NULL,
        .err = NULL,
        .completed = 0
    };
    pthread_mutex_init(&thread_data.mutex, NULL);
    pthread_cond_init(&thread_data.cond, NULL);
    
    // Start the fetch in a separate thread
    pthread_t fetch_thread;
    printf("Starting fetch operation in background thread...\n");
    if (pthread_create(&fetch_thread, NULL, fetch_thread_func, &thread_data) != 0) {
        fprintf(stderr, "Failed to create thread\n");
        pthread_mutex_destroy(&thread_data.mutex);
        pthread_cond_destroy(&thread_data.cond);
        return 1;
    }
    
    // Wait a short time, then cancel the operation
    printf("Waiting 1000ms before cancelling...\n");
    usleep(1000000);  // 1000ms
    
    // Check if we have a cancel handle and cancel
    pthread_mutex_lock(&thread_data.mutex);
    if (thread_data.cancelHandle != 0) {
        printf("Cancelling fetch operation (cancel handle: %lu)...\n", (unsigned long)thread_data.cancelHandle);
        GoWSK_balance_multistandardfetcher_CancelFetchBalances(thread_data.cancelHandle);
    }
    pthread_mutex_unlock(&thread_data.mutex);
    
    // Wait for the thread to complete
    pthread_join(fetch_thread, NULL);
    
    // Process results
    pthread_mutex_lock(&thread_data.mutex);
    if (thread_data.resultsJSON != NULL) {
        printf("Fetch returned (may be partial due to cancellation):\n%s\n", thread_data.resultsJSON);
        GoWSK_FreeCString(thread_data.resultsJSON);
    } else if (thread_data.err != NULL) {
        printf("Fetch error: %s\n", thread_data.err);
        GoWSK_FreeCString(thread_data.err);
    }
    
    // Clean up cancel handle
    if (thread_data.cancelHandle != 0) {
        GoWSK_balance_multistandardfetcher_FreeCancelHandle(thread_data.cancelHandle);
    }
    pthread_mutex_unlock(&thread_data.mutex);
    
    // Clean up synchronization primitives
    pthread_mutex_destroy(&thread_data.mutex);
    pthread_cond_destroy(&thread_data.cond);
    
    return 0;
}

// Example: Full fetch without cancellation
static int example_full_fetch(uintptr_t clientHandle, unsigned long chainID, const char* fetchConfigJSON) {
    printf("\n--- Example: Full fetch operation ---\n");
    
    char* err = NULL;
    uintptr_t cancelHandle = 0;
    unsigned long batchSize = 100;
    
    char* resultsJSON = GoWSK_balance_multistandardfetcher_FetchBalances(
        clientHandle, 
        chainID, 
        batchSize, 
        (char*)fetchConfigJSON,
        &cancelHandle,  // Get cancel handle (but don't use it)
        &err
    );
    
    if (resultsJSON == NULL) {
        fprintf(stderr, "FetchBalances error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        if (cancelHandle != 0) {
            GoWSK_balance_multistandardfetcher_FreeCancelHandle(cancelHandle);
        }
        return 1;
    }
    
    printf("FetchBalances Results:\n%s\n", resultsJSON);
    GoWSK_FreeCString(resultsJSON);
    
    // Clean up the cancel handle
    if (cancelHandle != 0) {
        GoWSK_balance_multistandardfetcher_FreeCancelHandle(cancelHandle);
    }
    
    return 0;
}

// Helper function to extract address from JSON account string
// JSON format: {"address":"0x...","url":"..."}
#define ADDRESS_PREFIX_LEN 11 // Length of '"address":"'

static char* extract_address_from_json(const char* json) {
    if (json == NULL) return NULL;
    const char* addr_start = strstr(json, "\"address\":\"");
    if (addr_start == NULL) return NULL;
    addr_start += ADDRESS_PREFIX_LEN; // Skip past '"address":"'
    const char* addr_end = strchr(addr_start, '"');
    if (addr_end == NULL) return NULL;
    
    // Validate address length (Ethereum addresses are 42 chars with '0x' prefix or 40 without)
    size_t len = addr_end - addr_start;
    if (len != 42 && len != 40) {
        // Invalid address length
        return NULL;
    }
    // Validate that address starts with "0x" if it's 42 characters
    if (len == 42 && (addr_start[0] != '0' || addr_start[1] != 'x')) {
        return NULL;
    }
    
    char* addr = (char*)malloc(len + 1);
    if (addr == NULL) return NULL;
    memcpy(addr, addr_start, len);
    addr[len] = '\0';
    return addr;
}

// Helper function to build a transaction JSON string matching the txJSON struct format
// Allocates memory that must be freed by caller
// For legacy transactions (type 0), v, r, s are required fields (even for unsigned transactions)
// Based on go-ethereum core/types/transaction_marshalling.go
static char* build_tx_json(const char* nonce, const char* gasPrice, const char* gas, 
                           const char* to, const char* value, const char* input) {
    // Build transaction JSON matching go-ethereum types.Transaction format
    // Type 0x0 = Legacy transaction
    // All numeric fields use hexutil format (hex strings with 0x prefix)
    // v, r, s are required fields - use "0x0" for unsigned transactions
    size_t len = snprintf(NULL, 0, 
        "{\"type\":\"0x0\",\"nonce\":\"%s\",\"gasPrice\":\"%s\",\"gas\":\"%s\",\"to\":\"%s\",\"value\":\"%s\",\"input\":\"%s\",\"v\":\"0x0\",\"r\":\"0x0\",\"s\":\"0x0\"}",
        nonce ? nonce : "0x0",
        gasPrice ? gasPrice : "0x3b9aca00",
        gas ? gas : "0x5208",
        to ? to : "0x0",
        value ? value : "0x0",
        input ? input : "0x");
    
    char* json = (char*)malloc(len + 1);
    if (json == NULL) return NULL;
    
    snprintf(json, len + 1,
        "{\"type\":\"0x0\",\"nonce\":\"%s\",\"gasPrice\":\"%s\",\"gas\":\"%s\",\"to\":\"%s\",\"value\":\"%s\",\"input\":\"%s\",\"v\":\"0x0\",\"r\":\"0x0\",\"s\":\"0x0\"}",
        nonce ? nonce : "0x0",
        gasPrice ? gasPrice : "0x3b9aca00",
        gas ? gas : "0x5208",
        to ? to : "0x0",
        value ? value : "0x0",
        input ? input : "0x");
    
    return json;
}

// Helper function to remove all files in a directory, then remove the directory
// Returns 0 on success, -1 on error
static int remove_directory_recursive(const char* dir_path) {
    DIR* dir = opendir(dir_path);
    if (dir == NULL) {
        return -1;
    }
    
    struct dirent* entry;
    char file_path[1024];
    
    // Remove all files in the directory
    while ((entry = readdir(dir)) != NULL) {
        // Skip . and ..
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
            continue;
        }
        
        // Build full path
        snprintf(file_path, sizeof(file_path), "%s/%s", dir_path, entry->d_name);
        
        // Remove the file
        if (remove(file_path) != 0) {
            closedir(dir);
            return -1;
        }
    }
    
    closedir(dir);
    
    // Now remove the empty directory
    if (rmdir(dir_path) != 0) {
        return -1;
    }
    
    return 0;
}

int example_accounts() {
    printf("\n=== Testing Accounts ===\n");
    char* err = NULL;
    
    // Test 1: Create a mnemonic
    printf("\n1. Creating mnemonic...\n");
    err = NULL;
    char* mnemonic = GoWSK_accounts_mnemonic_CreateRandomMnemonicWithDefaultLength(&err);
    if (mnemonic == NULL) {
        fprintf(stderr, "Failed to create mnemonic: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }
    printf("Mnemonic: %s\n", mnemonic);
    
    // Test 2: Create extended key from mnemonic
    printf("\n2. Creating extended key from mnemonic...\n");
    err = NULL;
    char* extKeyStr = GoWSK_accounts_keys_CreateExtKeyFromMnemonic(mnemonic, NULL, &err);
    if (extKeyStr == NULL) {
        fprintf(stderr, "Failed to create extended key: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_FreeCString(mnemonic);
        return 1;
    }
    printf("Extended Key: %s\n", extKeyStr);
    
    // Test 3: Derive a child key
    printf("\n3. Deriving child key...\n");
    const char* derivationPath = "m/44'/60'/0'/0/0";
    err = NULL;
    char* derivedKeyStr = GoWSK_accounts_keys_DeriveExtKey(extKeyStr, (char*)derivationPath, &err);
    if (derivedKeyStr == NULL) {
        fprintf(stderr, "Failed to derive key: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        return 1;
    }
    printf("Derived Key: %s\n", derivedKeyStr);
    
    // Test 4: Get ECDSA private key from extended key
    printf("\n4. Converting extended key to ECDSA...\n");
    err = NULL;
    char* privateKeyHex = GoWSK_accounts_keys_ExtKeyToECDSA(derivedKeyStr, &err);
    if (privateKeyHex == NULL) {
        fprintf(stderr, "Failed to convert to ECDSA: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        return 1;
    }
    printf("Private Key: %s\n", privateKeyHex);
    
    // Test 5: Get address from public key
    printf("\n5. Getting address from public key...\n");
    err = NULL;
    char* publicKeyHex = GoWSK_accounts_keys_ECDSAToPublicKey(privateKeyHex, &err);
    if (publicKeyHex == NULL) {
        fprintf(stderr, "Failed to get public key: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        return 1;
    }
    err = NULL;
    char* address = GoWSK_accounts_keys_PublicKeyToAddress(publicKeyHex, &err);
    if (address == NULL) {
        fprintf(stderr, "Failed to get address: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(publicKeyHex);
        return 1;
    }
    printf("Address: %s\n", address);
    GoWSK_FreeCString(publicKeyHex);
    
    // Test 6: Create keystore and extkeystore
    printf("\n6. Creating keystores...\n");
    // Generate unique directory names using timestamp
    time_t now = time(NULL);
    char keystoreDir[256];
    char extkeystoreDir[256];
    snprintf(keystoreDir, sizeof(keystoreDir), "/tmp/test_keystore_%ld", now);
    snprintf(extkeystoreDir, sizeof(extkeystoreDir), "/tmp/test_extkeystore_%ld", now);
    printf("Keystore directory: %s\n", keystoreDir);
    printf("ExtKeystore directory: %s\n", extkeystoreDir);
    // Use light scrypt for faster testing (LightScryptN = 4096, LightScryptP = 6)
    int scryptN = 4096;
    int scryptP = 6;
    
    err = NULL;
    unsigned long long ksHandle = GoWSK_accounts_keystore_NewKeyStore(keystoreDir, scryptN, scryptP, &err);
    if (ksHandle == 0) {
        fprintf(stderr, "Failed to create keystore: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("Keystore created\n");
    
    err = NULL;
    unsigned long long extKsHandle = GoWSK_accounts_extkeystore_NewKeyStore(extkeystoreDir, scryptN, scryptP, &err);
    if (extKsHandle == 0) {
        fprintf(stderr, "Failed to create extkeystore: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("ExtKeystore created\n");
    
    // Test 7: Create new accounts in both keystores
    printf("\n7. Creating new accounts...\n");
    const char* passphrase = "test123";
    
    err = NULL; // Reset error pointer
    char* ksAccount1JSON = GoWSK_accounts_keystore_NewAccount(ksHandle, (char*)passphrase, &err);
    if (ksAccount1JSON == NULL) {
        fprintf(stderr, "Failed to create account in keystore: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("Keystore Account 1: %s\n", ksAccount1JSON);
    
    err = NULL; // Reset error pointer
    char* extKsAccount1JSON = GoWSK_accounts_extkeystore_NewAccount(extKsHandle, (char*)passphrase, &err);
    if (extKsAccount1JSON == NULL) {
        fprintf(stderr, "Failed to create account in extkeystore: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_FreeCString(ksAccount1JSON);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("ExtKeystore Account 1: %s\n", extKsAccount1JSON);
    
    // Test 8: Import ECDSA private key into keystore
    printf("\n8. Importing ECDSA private key into keystore...\n");
    err = NULL; // Reset error pointer
    char* ksAccount2JSON = GoWSK_accounts_keystore_ImportECDSA(ksHandle, privateKeyHex, (char*)passphrase, &err);
    if (ksAccount2JSON == NULL) {
        fprintf(stderr, "Failed to import ECDSA key into keystore: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
        GoWSK_FreeCString(ksAccount1JSON);
        GoWSK_FreeCString(extKsAccount1JSON);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("Keystore Account 2 (imported): %s\n", ksAccount2JSON);
    
    // Extract address from imported account for later use
    char* importedAddress = extract_address_from_json(ksAccount2JSON);
    if (importedAddress == NULL) {
        fprintf(stderr, "Failed to extract address from imported account JSON\n");
        GoWSK_FreeCString(ksAccount1JSON);
        GoWSK_FreeCString(extKsAccount1JSON);
        GoWSK_FreeCString(ksAccount2JSON);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("Imported account address: %s\n", importedAddress);
    
    // Test 9: Import extended key into extkeystore
    printf("\n9. Importing extended key into extkeystore...\n");
    err = NULL; // Reset error pointer
    char* extKsAccount2JSON = GoWSK_accounts_extkeystore_ImportExtendedKey(extKsHandle, extKeyStr, (char*)passphrase, &err);
    if (extKsAccount2JSON == NULL) {
        fprintf(stderr, "Failed to import extended key into extkeystore: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
        free(importedAddress);
        GoWSK_FreeCString(ksAccount1JSON);
        GoWSK_FreeCString(extKsAccount1JSON);
        GoWSK_FreeCString(ksAccount2JSON);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("ExtKeystore Account 2 (imported): %s\n", extKsAccount2JSON);
    
    // Extract address from extkeystore imported account for later use
    char* extImportedAddress = extract_address_from_json(extKsAccount2JSON);
    if (extImportedAddress == NULL) {
        fprintf(stderr, "Failed to extract address from extkeystore imported account JSON\n");
        free(importedAddress);
        GoWSK_FreeCString(ksAccount1JSON);
        GoWSK_FreeCString(extKsAccount1JSON);
        GoWSK_FreeCString(ksAccount2JSON);
        GoWSK_FreeCString(extKsAccount2JSON);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        return 1;
    }
    printf("ExtKeystore imported account address: %s\n", extImportedAddress);
    
    // Test 10: Export from keystore
    printf("\n10. Exporting from keystore...\n");
    const char* newPassphrase = "newpass123";
    err = NULL; // Reset error pointer
    char* exportedKeyJSON = GoWSK_accounts_keystore_Export(ksHandle, importedAddress, (char*)passphrase, (char*)newPassphrase, &err);
    if (exportedKeyJSON == NULL) {
        fprintf(stderr, "Failed to export from keystore: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Exported key (first 100 chars): %.100s...\n", exportedKeyJSON);
        GoWSK_FreeCString(exportedKeyJSON);
    }
    
    // Test 11: Export from extkeystore (both formats)
    printf("\n11. Exporting from extkeystore...\n");
    err = NULL; // Reset error pointer
    char* exportedExtKeyJSON = GoWSK_accounts_extkeystore_ExportExt(extKsHandle, extImportedAddress, (char*)passphrase, (char*)newPassphrase, &err);
    if (exportedExtKeyJSON == NULL) {
        fprintf(stderr, "Failed to export extended key: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Exported extended key (first 100 chars): %.100s...\n", exportedExtKeyJSON);
        GoWSK_FreeCString(exportedExtKeyJSON);
    }
    
    err = NULL; // Reset error pointer
    char* exportedPrivKeyJSON = GoWSK_accounts_extkeystore_ExportPriv(extKsHandle, extImportedAddress, (char*)passphrase, (char*)newPassphrase, &err);
    if (exportedPrivKeyJSON == NULL) {
        fprintf(stderr, "Failed to export private key: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Exported private key (first 100 chars): %.100s...\n", exportedPrivKeyJSON);
        // Keep exportedPrivKeyJSON for import test below
    }
    
    // Test 12: Import exported private key from extkeystore into keystore
    printf("\n12. Importing exported private key from extkeystore into keystore...\n");
    if (exportedPrivKeyJSON != NULL) {
        err = NULL; // Reset error pointer
        char* importedFromExtKsJSON = GoWSK_accounts_keystore_Import(ksHandle, exportedPrivKeyJSON, (char*)newPassphrase, (char*)passphrase, &err);
        if (importedFromExtKsJSON == NULL) {
            fprintf(stderr, "Failed to import exported private key into keystore: %s\n", err ? err : "unknown error");
            if (err) {
                GoWSK_FreeCString(err);
                err = NULL;
            }
            GoWSK_FreeCString(exportedPrivKeyJSON);
        } else {
            printf("Successfully imported private key from extkeystore into keystore: %s\n", importedFromExtKsJSON);
            GoWSK_FreeCString(importedFromExtKsJSON);
            GoWSK_FreeCString(exportedPrivKeyJSON);
        }
    } else {
        fprintf(stderr, "Skipping import test - no exported private key available\n");
    }
    
    // Test 13: List accounts
    printf("\n13. Listing accounts...\n");
    err = NULL; // Reset error pointer
    char* ksAccounts = GoWSK_accounts_keystore_Accounts(ksHandle, &err);
    if (ksAccounts == NULL) {
        fprintf(stderr, "Failed to list keystore accounts: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Keystore accounts: %s\n", ksAccounts);
        GoWSK_FreeCString(ksAccounts);
    }
    
    err = NULL; // Reset error pointer
    char* extKsAccounts = GoWSK_accounts_extkeystore_Accounts(extKsHandle, &err);
    if (extKsAccounts == NULL) {
        fprintf(stderr, "Failed to list extkeystore accounts: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("ExtKeystore accounts: %s\n", extKsAccounts);
        GoWSK_FreeCString(extKsAccounts);
    }
    
    // Test 14: Unlock and sign
    printf("\n14. Testing unlock and sign...\n");
    const char* testHash = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
    err = NULL; // Reset error pointer
    GoWSK_accounts_keystore_Unlock(ksHandle, importedAddress, (char*)passphrase, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to unlock keystore account: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("Keystore account unlocked\n");
        
        // Sign a test hash
        err = NULL; // Reset error pointer
        char* signature = GoWSK_accounts_keystore_SignHash(ksHandle, importedAddress, (char*)testHash, &err);
        if (signature == NULL) {
            fprintf(stderr, "Failed to sign hash: %s\n", err ? err : "unknown error");
            if (err) {
                GoWSK_FreeCString(err);
                err = NULL;
            }
        } else {
            printf("Signature: %s\n", signature);
            GoWSK_FreeCString(signature);
        }
        
        err = NULL; // Reset error pointer
        GoWSK_accounts_keystore_Lock(ksHandle, importedAddress, &err);
        if (err != NULL) {
            fprintf(stderr, "Failed to lock keystore account: %s\n", err);
            GoWSK_FreeCString(err);
            err = NULL;
        } else {
            printf("Keystore account locked\n");
        }
    }
    
    // Test 15: Derive child account in extkeystore
    printf("\n15. Deriving child account in extkeystore...\n");
    const char* childPath = "m/44'/60'/0'/0/1";
    err = NULL; // Reset error pointer
    char* childAccountJSON = GoWSK_accounts_extkeystore_DeriveWithPassphrase(
        extKsHandle, extImportedAddress, (char*)childPath, 0, (char*)passphrase, NULL, &err);
    if (childAccountJSON == NULL) {
        fprintf(stderr, "Failed to derive child account: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Child account: %s\n", childAccountJSON);
        GoWSK_FreeCString(childAccountJSON);
    }
    
    // Test 16: Check HasAddress for both keystores
    printf("\n16. Checking HasAddress...\n");
    err = NULL;
    int hasAddr = GoWSK_accounts_keystore_HasAddress(ksHandle, importedAddress, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to check HasAddress in keystore: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("Keystore HasAddress(%s): %d\n", importedAddress, hasAddr);
    }
    
    err = NULL;
    hasAddr = GoWSK_accounts_extkeystore_HasAddress(extKsHandle, extImportedAddress, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to check HasAddress in extkeystore: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("ExtKeystore HasAddress(%s): %d\n", extImportedAddress, hasAddr);
    }
    
    // Test 17: TimedUnlock for both keystores
    printf("\n17. Testing TimedUnlock...\n");
    err = NULL;
    GoWSK_accounts_keystore_TimedUnlock(ksHandle, importedAddress, (char*)passphrase, 5, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to TimedUnlock keystore account: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("Keystore account unlocked for 5 seconds\n");
    }
    
    err = NULL;
    GoWSK_accounts_extkeystore_TimedUnlock(extKsHandle, extImportedAddress, (char*)passphrase, 5, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to TimedUnlock extkeystore account: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("ExtKeystore account unlocked for 5 seconds\n");
    }
    
    // Test 18: Update passphrase
    printf("\n18. Updating passphrase...\n");
    const char* updatedPassphrase = "updated123";
    err = NULL;
    GoWSK_accounts_keystore_Update(ksHandle, importedAddress, (char*)passphrase, (char*)updatedPassphrase, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to update keystore passphrase: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("Keystore passphrase updated successfully\n");
        // Update back to original for remaining tests
        err = NULL;
        GoWSK_accounts_keystore_Update(ksHandle, importedAddress, (char*)updatedPassphrase, (char*)passphrase, &err);
        if (err != NULL) {
            fprintf(stderr, "Failed to revert keystore passphrase: %s\n", err);
            GoWSK_FreeCString(err);
            err = NULL;
        }
    }
    
    err = NULL;
    GoWSK_accounts_extkeystore_Update(extKsHandle, extImportedAddress, (char*)passphrase, (char*)updatedPassphrase, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to update extkeystore passphrase: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("ExtKeystore passphrase updated successfully\n");
        // Update back to original for remaining tests
        err = NULL;
        GoWSK_accounts_extkeystore_Update(extKsHandle, extImportedAddress, (char*)updatedPassphrase, (char*)passphrase, &err);
        if (err != NULL) {
            fprintf(stderr, "Failed to revert extkeystore passphrase: %s\n", err);
            GoWSK_FreeCString(err);
            err = NULL;
        }
    }
    
    // Test 19: SignHashWithPassphrase
    printf("\n19. Testing SignHashWithPassphrase...\n");
    const char* testHash2 = "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321";
    err = NULL;
    char* signature2 = GoWSK_accounts_keystore_SignHashWithPassphrase(ksHandle, importedAddress, (char*)passphrase, (char*)testHash2, &err);
    if (signature2 == NULL) {
        fprintf(stderr, "Failed to sign hash with passphrase (keystore): %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Keystore signature (with passphrase): %s\n", signature2);
        GoWSK_FreeCString(signature2);
    }
    
    err = NULL;
    signature2 = GoWSK_accounts_extkeystore_SignHashWithPassphrase(extKsHandle, extImportedAddress, (char*)passphrase, (char*)testHash2, &err);
    if (signature2 == NULL) {
        fprintf(stderr, "Failed to sign hash with passphrase (extkeystore): %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("ExtKeystore signature (with passphrase): %s\n", signature2);
        GoWSK_FreeCString(signature2);
    }
    
    // Test 20: SignTx and SignTxWithPassphrase
    printf("\n20. Testing SignTx...\n");
    // Build proper transaction JSON matching the txJSON struct format
    char* txJSON = build_tx_json(
        "0x0",                                    // nonce
        "0x3b9aca00",                             // gasPrice (1 gwei)
        "0x5208",                                  // gas (21000)
        "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045", // to address
        "0x2386f26fc10000",                        // value (0.01 ETH)
        "0x"                                       // input (empty)
    );
    if (txJSON == NULL) {
        fprintf(stderr, "Failed to build transaction JSON\n");
        free(importedAddress);
        free(extImportedAddress);
        GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
        GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
        GoWSK_FreeCString(mnemonic);
        GoWSK_FreeCString(extKeyStr);
        GoWSK_FreeCString(derivedKeyStr);
        GoWSK_FreeCString(privateKeyHex);
        GoWSK_FreeCString(address);
        GoWSK_FreeCString(ksAccount1JSON);
        GoWSK_FreeCString(extKsAccount1JSON);
        GoWSK_FreeCString(ksAccount2JSON);
        GoWSK_FreeCString(extKsAccount2JSON);
        return 1;
    }
    const char* chainIDHex = "0x1";
    
    // First unlock for SignTx
    err = NULL;
    GoWSK_accounts_keystore_Unlock(ksHandle, importedAddress, (char*)passphrase, &err);
    if (err == NULL) {
        err = NULL;
        char* signedTx = GoWSK_accounts_keystore_SignTx(ksHandle, importedAddress, (char*)txJSON, (char*)chainIDHex, &err);
        if (signedTx == NULL) {
            fprintf(stderr, "Failed to sign transaction (keystore): %s\n", err ? err : "unknown error");
            if (err) {
                GoWSK_FreeCString(err);
                err = NULL;
            }
        } else {
            printf("Keystore signed transaction: %s\n", signedTx);
            GoWSK_FreeCString(signedTx);
        }
    }
    
    err = NULL;
    char* signedTx2 = GoWSK_accounts_keystore_SignTxWithPassphrase(ksHandle, importedAddress, (char*)passphrase, (char*)txJSON, (char*)chainIDHex, &err);
    if (signedTx2 == NULL) {
        fprintf(stderr, "Failed to sign transaction with passphrase (keystore): %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Keystore signed transaction (with passphrase): %s\n", signedTx2);
        GoWSK_FreeCString(signedTx2);
    }
    
    err = NULL;
    GoWSK_accounts_extkeystore_Unlock(extKsHandle, extImportedAddress, (char*)passphrase, &err);
    if (err == NULL) {
        err = NULL;
        char* signedTx3 = GoWSK_accounts_extkeystore_SignTx(extKsHandle, extImportedAddress, (char*)txJSON, (char*)chainIDHex, &err);
        if (signedTx3 == NULL) {
            fprintf(stderr, "Failed to sign transaction (extkeystore): %s\n", err ? err : "unknown error");
            if (err) {
                GoWSK_FreeCString(err);
                err = NULL;
            }
        } else {
            printf("ExtKeystore signed transaction: %s\n", signedTx3);
            GoWSK_FreeCString(signedTx3);
        }
    }
    
    err = NULL;
    char* signedTx4 = GoWSK_accounts_extkeystore_SignTxWithPassphrase(extKsHandle, extImportedAddress, (char*)passphrase, (char*)txJSON, (char*)chainIDHex, &err);
    if (signedTx4 == NULL) {
        fprintf(stderr, "Failed to sign transaction with passphrase (extkeystore): %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("ExtKeystore signed transaction (with passphrase): %s\n", signedTx4);
        GoWSK_FreeCString(signedTx4);
    }
    
    // Free transaction JSON
    free(txJSON);
    
    // Test 21: Find account
    printf("\n21. Testing Find account...\n");
    // Extract URL from account JSON for Find
    char* ksAccount1Address = extract_address_from_json(ksAccount1JSON);
    if (ksAccount1Address != NULL) {
        err = NULL;
        char* foundAccount = GoWSK_accounts_keystore_Find(ksHandle, ksAccount1Address, NULL, &err);
        if (foundAccount == NULL) {
            fprintf(stderr, "Failed to find account (keystore): %s\n", err ? err : "unknown error");
            if (err) {
                GoWSK_FreeCString(err);
                err = NULL;
            }
        } else {
            printf("Keystore found account: %s\n", foundAccount);
            GoWSK_FreeCString(foundAccount);
        }
        free(ksAccount1Address);
    }
    
    char* extKsAccount1Address = extract_address_from_json(extKsAccount1JSON);
    if (extKsAccount1Address != NULL) {
        err = NULL;
        char* foundAccount2 = GoWSK_accounts_extkeystore_Find(extKsHandle, extKsAccount1Address, NULL, &err);
        if (foundAccount2 == NULL) {
            fprintf(stderr, "Failed to find account (extkeystore): %s\n", err ? err : "unknown error");
            if (err) {
                GoWSK_FreeCString(err);
                err = NULL;
            }
        } else {
            printf("ExtKeystore found account: %s\n", foundAccount2);
            GoWSK_FreeCString(foundAccount2);
        }
        free(extKsAccount1Address);
    }
    
    // Test 22: ExtKeystore Unlock/Lock
    printf("\n22. Testing ExtKeystore Unlock/Lock...\n");
    err = NULL;
    GoWSK_accounts_extkeystore_Unlock(extKsHandle, extImportedAddress, (char*)passphrase, &err);
    if (err != NULL) {
        fprintf(stderr, "Failed to unlock extkeystore account: %s\n", err);
        GoWSK_FreeCString(err);
        err = NULL;
    } else {
        printf("ExtKeystore account unlocked\n");
        
        // Sign hash with unlocked account
        err = NULL;
        char* signature3 = GoWSK_accounts_extkeystore_SignHash(extKsHandle, extImportedAddress, (char*)testHash, &err);
        if (signature3 == NULL) {
            fprintf(stderr, "Failed to sign hash (extkeystore unlocked): %s\n", err ? err : "unknown error");
            if (err) {
                GoWSK_FreeCString(err);
                err = NULL;
            }
        } else {
            printf("ExtKeystore signature (unlocked): %s\n", signature3);
            GoWSK_FreeCString(signature3);
        }
        
        err = NULL;
        GoWSK_accounts_extkeystore_Lock(extKsHandle, extImportedAddress, &err);
        if (err != NULL) {
            fprintf(stderr, "Failed to lock extkeystore account: %s\n", err);
            GoWSK_FreeCString(err);
            err = NULL;
        } else {
            printf("ExtKeystore account locked\n");
        }
    }
    
    // Test 23: ExtKeystore Import (extended key format)
    printf("\n23. Testing ExtKeystore Import (extended key format)...\n");
    // Import an extended key (extkeystore can only import extended keys, not private keys)
    // Use the extKeyStr from Test 2 to demonstrate importing an extended key
    err = NULL;
    char* importedExtKey = GoWSK_accounts_extkeystore_ImportExtendedKey(extKsHandle, extKeyStr, (char*)passphrase, &err);
    if (importedExtKey == NULL) {
        fprintf(stderr, "Failed to import extended key to extkeystore: %s\n", err ? err : "unknown error");
        if (err) {
            GoWSK_FreeCString(err);
            err = NULL;
        }
    } else {
        printf("Successfully imported extended key to extkeystore: %s\n", importedExtKey);
        GoWSK_FreeCString(importedExtKey);
    }
    
    // Test 24: Delete account (create a temporary account first)
    printf("\n24. Testing Delete account...\n");
    err = NULL;
    char* tempAccount = GoWSK_accounts_keystore_NewAccount(ksHandle, (char*)passphrase, &err);
    if (tempAccount != NULL) {
        char* tempAddress = extract_address_from_json(tempAccount);
        if (tempAddress != NULL) {
            err = NULL;
            GoWSK_accounts_keystore_Delete(ksHandle, tempAddress, (char*)passphrase, &err);
            if (err != NULL) {
                fprintf(stderr, "Failed to delete account: %s\n", err);
                GoWSK_FreeCString(err);
                err = NULL;
            } else {
                printf("Successfully deleted temporary account\n");
            }
            free(tempAddress);
        }
        GoWSK_FreeCString(tempAccount);
    }
    
    err = NULL;
    tempAccount = GoWSK_accounts_extkeystore_NewAccount(extKsHandle, (char*)passphrase, &err);
    if (tempAccount != NULL) {
        char* tempAddress = extract_address_from_json(tempAccount);
        if (tempAddress != NULL) {
            err = NULL;
            GoWSK_accounts_extkeystore_Delete(extKsHandle, tempAddress, (char*)passphrase, &err);
            if (err != NULL) {
                fprintf(stderr, "Failed to delete extkeystore account: %s\n", err);
                GoWSK_FreeCString(err);
                err = NULL;
            } else {
                printf("Successfully deleted temporary extkeystore account\n");
            }
            free(tempAddress);
        }
        GoWSK_FreeCString(tempAccount);
    }
    
    // Cleanup
    printf("\n26. Cleaning up...\n");
    GoWSK_FreeCString(mnemonic);
    GoWSK_FreeCString(extKeyStr);
    GoWSK_FreeCString(derivedKeyStr);
    GoWSK_FreeCString(privateKeyHex);
    GoWSK_FreeCString(address);
    GoWSK_FreeCString(ksAccount1JSON);
    GoWSK_FreeCString(extKsAccount1JSON);
    GoWSK_FreeCString(ksAccount2JSON);
    GoWSK_FreeCString(extKsAccount2JSON);
    free(importedAddress);
    free(extImportedAddress);
    GoWSK_accounts_keystore_CloseKeyStore(ksHandle);
    GoWSK_accounts_extkeystore_CloseKeyStore(extKsHandle);
    
    // Clean up temporary directories (remove all files first, then directories)
    remove_directory_recursive(keystoreDir);
    remove_directory_recursive(extkeystoreDir);
    
    printf("\n=== Accounts test completed successfully ===\n");
    return 0;
}

int main(int argc, char** argv) {
    const char* url = "https://ethereum-rpc.publicnode.com";
    const char* addr = "0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045"; // vitalik.eth

    char* err = NULL;
    unsigned long long h = GoWSK_ethclient_NewClient((char*)url, &err);
    if (h == 0) {
        fprintf(stderr, "Failed to create client: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        return 1;
    }

    // Get chain ID for later examples
    char* chain = GoWSK_ethclient_ChainID(h, &err);
    if (chain == NULL) {
        fprintf(stderr, "ChainID error: %s\n", err ? err : "unknown error");
        if (err) GoWSK_FreeCString(err);
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }
    // Parse chain ID before freeing the string
    char* endptr;
    unsigned long chainID = strtoul(chain, &endptr, 0);
    if (*endptr != '\0' || endptr == chain) {
        fprintf(stderr, "Failed to parse chain ID\n");
        GoWSK_FreeCString(chain);
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }
    GoWSK_FreeCString(chain);

    // Run basic operations example
    if (example_basic_operations((uintptr_t)h, addr) != 0) {
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }

    // Example: Fetch balances using multistandardfetcher
    printf("\n=== Fetching balances with multistandardfetcher ===\n");
    
    // Create fetch config JSON: native balance + ERC20 tokens + ERC721 NFTs + ERC1155 collectibles
    // ERC20 tokens:
    //   USDC: 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48
    //   SHIB: 0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE
    // ERC721 NFTs:
    //   Bored Ape Yacht Club: 0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D
    //   Pudgy Penguins: 0xbd3531da5cf5857e7cfaa92426877b022e612cf8
    // ERC1155 collectibles (format: "contractAddress:tokenID"):
    //   OpenSea Shared Storefront: 0x495f947276749Ce646f68AC8c248420045cb7b5e:80725417304363601833901294931248829736335313578142415985923215537121414611044
    //   Parallel Alpha: 0x76BE3b62873462d2142405439777e971754E8E77:1
    const char* fetchConfigJSON = 
        "{"
        "\"native\":[\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\"],"
        "\"erc20\":{"
        "\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\":["
        "\"0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48\","
        "\"0x95aD61b0a150d79219dCF64E1E6Cc01f0B64C4cE\""
        "]"
        "},"
        "\"erc721\":{"
        "\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\":["
        "\"0xBC4CA0EdA7647A8aB7C2061c2E118A18a936f13D\","
        "\"0xbd3531da5cf5857e7cfaa92426877b022e612cf8\""
        "]"
        "},"
        "\"erc1155\":{"
        "\"0xd8dA6BF26964aF9D7eEd9e03E53415D37aA96045\":["
        "\"0x495f947276749Ce646f68AC8c248420045cb7b5e:80725417304363601833901294931248829736335313578142415985923215537121414611044\","
        "\"0x76BE3b62873462d2142405439777e971754E8E77:1\""
        "]"
        "}"
        "}";
    
    // Run cancellation example
    if (example_cancellation_with_threading((uintptr_t)h, chainID, fetchConfigJSON) != 0) {
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }
    
    // Run full fetch example
    if (example_full_fetch((uintptr_t)h, chainID, fetchConfigJSON) != 0) {
        GoWSK_ethclient_CloseClient(h);
        return 1;
    }

    GoWSK_ethclient_CloseClient(h);

    // Run accounts example
    if (example_accounts() != 0) {
        return 1;
    }

    return 0;
}